// Code generated by nullable_struct. DO NOT EDIT.

package {{.Package}}

import (
	"bytes"
	"encoding/json"
	)

// NullableValue is a nullable value. It supports JSON serialization.
type Nullable{{.Type}} struct {
	value *{{.Type}}
	valid bool
}

var (
	Null{{.Type}} = Nullable{{.Type}}{valid: false}
	empty{{.Type}}Bytes   = []byte(``)
	empty{{.Type}}JSON    = []byte(`""`)
	null{{.Type}}Bytes    = []byte("null")
)

// {{.Type}}From creates a new Nullable{{.Type}}
func Nullable{{.Type}}From(value {{.Type}}) Nullable{{.Type}} {
	return newNullable{{.Type}}(&value, true)
}

// {{.Type}}FromPtr creates a new Nullable{{.Type}} that be null if value is nil.
func Nullable{{.Type}}FromPtr(value *{{.Type}}) Nullable{{.Type}} {
	if value == nil {
		return Null{{.Type}}
	}
	return newNullable{{.Type}}(value, true)
}

// newNullable{{.Type}} creates a new Nullable{{.Type}}
func newNullable{{.Type}}(valuePtr *{{.Type}}, valid bool) Nullable{{.Type}} {
	return Nullable{{.Type}}{
		value: valuePtr,
		valid: valid,
	}
}

// Valid returns true if Nullable{{.Type}} is not null.
func (v Nullable{{.Type}}) Valid() bool {
	return v.valid
}

// Ptr returns a pointer to this Nullable{{.Type}}'s value, or a nil pointer if this Nullable{{.Type}} is null.
func (v Nullable{{.Type}}) Ptr() *{{.Type}} {
	if !v.valid {
		return nil
	}
	return v.value
}

// UnmarshalJSON implements json.Unmarshaler.
func (v *Nullable{{.Type}}) UnmarshalJSON(data []byte) error {
	var value {{.Type}}
	if bytes.Equal(data, empty{{.Type}}Bytes) || bytes.Equal(data, null{{.Type}}Bytes) || bytes.Equal(data, empty{{.Type}}JSON) {
		v.value = nil
		v.valid = false
		return nil
	}
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	v.value = &value
	v.valid = true
	return nil
}

// MarshalJSON implements json.Marshaler.
func (v Nullable{{.Type}}) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}
